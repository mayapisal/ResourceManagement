<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapping1 DApp</title>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f4f6f8; }
    table { border-collapse: collapse; width: 95%; margin: 15px 0; }
    th, td { border: 1px solid #999; padding: 8px; text-align: center; }
    th { background: #3498db; color: white; }
    button { padding: 6px 12px; margin: 5px; border-radius: 6px; border: none; background: #3498db; color: white; cursor: pointer; }
    button:hover { background: #2980b9; }
    input { padding: 6px; margin: 5px; }
    .error { color: red; font-weight: bold; }
    h2, h3 { color: #2c3e50; }
  </style>
</head>
<body>
  <h2>üìä Mapping1 DApp</h2>
  <button onclick="connectWallet()">üîó Connect Wallet</button>
  <p id="wallet">Not Connected</p>
  <p id="errorMsg" class="error"></p>

<h3>‚ö° Run Allocation</h3>
  <input id="maxDemandsInput" type="number" placeholder="Max demands to allocate">
  <button onclick="runAllocation()">‚ñ∂Ô∏è Run Allocation</button>
  <p id="allocationStatus"></p>

  <h3>All Allocation Matrices</h3>
  <button onclick="getAllMatrixIds()">üìä Load All Matrices</button>
  <div id="matrices"></div>

  <h3>Matrix Views</h3>
  <input id="matrixIdInput" type="number" placeholder="Enter Matrix ID">
  <div>
    <button onclick="getAllocationMatrix()">üìã Allocation Matrix</button>
    <button onclick="downloadAllocationCSV()">‚¨áÔ∏è Download Allocation CSV</button>
    <button onclick="getDemandMatrix()">üìå Demand Matrix</button>
    <button onclick="downloadDemandCSV()">‚¨áÔ∏è Download Demand CSV</button>
    <button onclick="getSupplierMatrix()">üè≠ Supplier Matrix</button>
    <button onclick="downloadSupplierCSV()">‚¨áÔ∏è Download Supplier CSV</button>
  </div>

  <div id="allocationMatrix"></div>
  <div id="demandMatrix"></div>
  <div id="supplierMatrix"></div>


   <h3>üîé Allocation Details</h3>
  <input id="allocationIdInput" type="number" placeholder="Enter Allocation ID">
  <button onclick="getAllocationDetails()">üìÑ Get Allocation</button>
  <div id="allocationDetails"></div>

  <h3>üìå Latest Allocation by Demand + Resource</h3>
  <input id="demandIdInput" type="number" placeholder="Demand ID">
  <input id="resourceTypeInput" type="text" placeholder="Resource (e.g. WATER)">
  <button onclick="getLatestAllocation()">üîç Get Latest Allocation</button>
  <p id="latestAllocation"></p>



  <script>
    let web3, mapping1, demandProvider;
    let lastAllocationData = null;
    let lastDemandData = null;
    let lastSupplierData = null;

    const mapping1Address = "0x0311688aa5C8a5C9fFa855dc197Af2763C60dFc0";
    const demandProviderAddress = "0x0Fd8c75153d66265604Dbca4FB9f8B0eD9dD583A";

    const mapping1Abi = [
        {
        "inputs":[{"internalType":"uint256","name":"maxDemands","type":"uint256"}],
        "name":"runAllocation",
        "outputs":[],
        "stateMutability":"nonpayable","type":"function"
      },
      {
        
        "inputs":[{"internalType":"uint256","name":"matrixId","type":"uint256"}],
        "name":"getMatrixDetails",
        "outputs":[
          {"internalType":"uint256","name":"id","type":"uint256"},
          {"internalType":"uint256[]","name":"allocationIds","type":"uint256[]"},
          {"internalType":"uint256[]","name":"allocationDNos","type":"uint256[]"},
          {"internalType":"string[]","name":"allocatedTo","type":"string[]"},
          {"internalType":"string[]","name":"resourceTypes","type":"string[]"},
          {"internalType":"uint256[]","name":"allocatedQty","type":"uint256[]"}
        ],
        "stateMutability":"view","type":"function"
      },
      {
        "inputs":[],"name":"getAllMatrixIds",
        "outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],
        "stateMutability":"view","type":"function"
      },
      {
        "inputs":[{"internalType":"uint256","name":"allocationId","type":"uint256"}],
        "name":"getAllocationDetails",
        "outputs":[
          {"internalType":"uint256","name":"","type":"uint256"},
          {"internalType":"uint256","name":"","type":"uint256"},
          {"internalType":"string","name":"","type":"string"},
          {"internalType":"uint256","name":"","type":"uint256"},
          {"internalType":"string","name":"","type":"string"},
          {"internalType":"string","name":"","type":"string"},
          {"internalType":"uint256","name":"","type":"uint256"}
        ],
        "stateMutability":"view","type":"function"
      },
      {
        "inputs":[{"internalType":"uint256","name":"","type":"uint256"}],
        "name":"allocationMatrices",
        "outputs":[
          {"internalType":"uint256","name":"matrixId","type":"uint256"},
          {"internalType":"uint256","name":"timestamp","type":"uint256"}
        ],
        "stateMutability":"view","type":"function"
      },
    
    
      {
        "inputs":[
          {"internalType":"uint256","name":"demandId","type":"uint256"},
          {"internalType":"string","name":"resourceType","type":"string"}
        ],
        "name":"getLatestAllocationForDemandResource",
        "outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
        "stateMutability":"view","type":"function"
      }
    
    ];

    const demandProviderAbi = [
      {
        "inputs":[{"internalType":"uint256","name":"_DNo","type":"uint256"}],
        "name":"viewDemandsByDNo",
        "outputs":[
          {"internalType":"string","name":"DID","type":"string"},
          {"internalType":"string[]","name":"resourceTypes","type":"string[]"},
          {"internalType":"uint256[]","name":"quantities","type":"uint256[]"},
          {"internalType":"uint8[]","name":"criticalities","type":"uint8[]"},
          {"internalType":"string[]","name":"statuses","type":"string[]"},
          {"internalType":"uint256[]","name":"createdAts","type":"uint256[]"},
          {"internalType":"uint256[]","name":"updatedAts","type":"uint256[]"}
        ],
        "stateMutability":"view","type":"function"
      }
    ];


    function showError(msg) {
      document.getElementById("errorMsg").innerText = msg;
      setTimeout(() => { document.getElementById("errorMsg").innerText = ""; }, 5000);
    }

    async function connectWallet() {
      if (window.ethereum) {
        web3 = new Web3(window.ethereum);
        await window.ethereum.request({ method: "eth_requestAccounts" });
        const accounts = await web3.eth.getAccounts();
        document.getElementById("wallet").innerText = "Connected: " + accounts[0];

        mapping1 = new web3.eth.Contract(mapping1Abi, mapping1Address);
        demandProvider = new web3.eth.Contract(demandProviderAbi, demandProviderAddress);
      } else {
        showError("Please install MetaMask!");
      }
    }

     async function runAllocation() {
      try {
        const maxDemands = document.getElementById("maxDemandsInput").value;
        await mapping1.methods.runAllocation(maxDemands).send({ from: currentAccount });
        document.getElementById("allocationStatus").innerText = "‚úÖ Allocation executed!";
      } catch (err) {
        showError("Error running allocation: " + err.message);
      }
    }

    async function getAllocationDetails() {
      try {
        const id = document.getElementById("allocationIdInput").value;
        const data = await mapping1.methods.getAllocationDetails(id).call();
        const html = `
          <h4>Allocation #${data[0]}</h4>
          <p>DNO: ${data[1]}</p>
          <p>Status: ${data[2]}</p>
          <p>Supplier ID: ${data[3]}</p>
          <p>Supplier Flag: ${data[4]}</p>
          <p>Resource: ${data[5]}</p>
          <p>Qty: ${data[6]}</p>
        `;
        document.getElementById("allocationDetails").innerHTML = html;
      } catch (err) {
        showError("Error fetching allocation details: " + err.message);
      }
    }

    async function getLatestAllocation() {
      try {
        const demandId = document.getElementById("demandIdInput").value;
        const resource = document.getElementById("resourceTypeInput").value;
        const allocId = await mapping1.methods.getLatestAllocationForDemandResource(demandId, resource).call();
        document.getElementById("latestAllocation").innerText = "Latest Allocation ID: " + allocId;
      } catch (err) {
        showError("Error fetching latest allocation: " + err.message);
      }
    }
    
    async function getAllMatrixIds() {
      try {
        const ids = await mapping1.methods.getAllMatrixIds().call();
        let html = "<table><tr><th>Matrix ID</th></tr>";
        ids.forEach(id => { html += `<tr><td>${id}</td></tr>`; });
        html += "</table>";
        document.getElementById("matrices").innerHTML = html;
      } catch (err) {
        showError("Error fetching matrices: " + err.message);
      }
    }

    // ================= ALLOCATION MATRIX =================
    async function getAllocationMatrix() {
  try {
    const id = document.getElementById("matrixIdInput").value;
    const data = await mapping1.methods.getMatrixDetails(id).call();
    const matrixInfo = await mapping1.methods.allocationMatrices(id).call();
    const timestamp = new Date(matrixInfo.timestamp * 1000).toLocaleString();

    // Define all resources to display
    const allResources = ["WATER", "FOOD","MEDICINE", "CLOTHS"];

    // Transform data into the new format
    const rows = [];
    for (let i = 0; i < data[1].length; i++) {
      const row = { "Allocation no": data[1][i], "DNO": data[2][i] };
      allResources.forEach(r => row[r] = "-"); // default "-"
      const resource = data[4][i].toUpperCase();
      if (allResources.includes(resource)) row[resource] = data[5][i]; // allocated quantity
      rows.push(row);
    }

    lastAllocationData = { rows, timestamp, matrixId: id, headers: ["Allocation no", "DNO", ...allResources] };

    // Render HTML table
    let html = `<h3>üìã Allocation Matrix #${id} | Created: ${timestamp}</h3>`;
    html += "<table><tr>";
    lastAllocationData.headers.forEach(h => html += `<th>${h}</th>`);
    html += "</tr>";
    rows.forEach(r => {
      html += "<tr>";
      lastAllocationData.headers.forEach(h => html += `<td>${r[h]}</td>`);
      html += "</tr>";
    });
    html += "</table>";
    document.getElementById("allocationMatrix").innerHTML = html;

  } catch (err) {
    showError("Error fetching allocation matrix: " + err.message);
  }
}

function downloadAllocationCSV() {
  if (!lastAllocationData) return showError("Please load the Allocation Matrix first!");
  const { rows, timestamp, matrixId, headers } = lastAllocationData;
  const csvRows = [];
  csvRows.push(headers.join(","));
  rows.forEach(r => csvRows.push(headers.map(h => `"${r[h]}"`).join(",")));
  const csv = csvRows.join("\n");
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  const timeStr = timestamp.replace(/[: ,]/g, "_");
  a.href = url;
  a.download = `Allocation_Matrix_${matrixId}_${timeStr}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

    // ================= DEMAND MATRIX =================
    async function getDemandMatrix() {
      try {
        const id = document.getElementById("matrixIdInput").value;
        const data = await mapping1.methods.getMatrixDetails(id).call();
        const matrixInfo = await mapping1.methods.allocationMatrices(id).call();
        const timestamp = new Date(matrixInfo.timestamp * 1000).toLocaleString();

        const grouped = {};
        for (let i = 0; i < data[1].length; i++) {
          const dno = data[2][i];
          const resource = data[4][i].toUpperCase();
          const qty = data[5][i];
          const demand = await demandProvider.methods.viewDemandsByDNo(dno).call();
          const did = demand.DID;

          if (!grouped[dno]) grouped[dno] = { DID: did, DNO: dno, WATER: 0, FOOD: 0, MEDICINE: 0,  CLOTHS: 0 };
          if (grouped[dno][resource] !== undefined) grouped[dno][resource] = qty;
        }

        lastDemandData = { grouped, timestamp, matrixId: id };

        let html = `<h3>üìå Demand Matrix | Created: ${timestamp}</h3>`;
        html += "<table><tr><th>DID</th><th>DNO</th><th>WATER</th><th>FOOD</th><th>MEDICINE</th><th>CLOTHS</th></tr>";
        Object.values(grouped).forEach(row => {
          html += `<tr>
            <td>${row.DID}</td>
            <td>${row.DNO}</td>
            <td>${row.WATER}</td>
            <td>${row.FOOD}</td>
            <td>${row.MEDICINE}</td>
            <td>${row.CLOTHS}</td>
          </tr>`;
        });
        html += "</table>";
        document.getElementById("demandMatrix").innerHTML = html;
      } catch (err) {
        showError("Error fetching demand matrix: " + err.message);
      }
    }

    function downloadDemandCSV() {
      if (!lastDemandData) return showError("Please load the Demand Matrix first!");
      const { grouped, timestamp, matrixId } = lastDemandData;
      const headers = ["DID", "DNO", "WATER", "FOOD", "MEDICINE", "CLOTHS"];
      const rows = Object.values(grouped).map(r => [r.DID, r.DNO, r.WATER,  r.FOOD,r.MEDICINE, r.CLOTHS]);
      downloadCSV("Demand", matrixId, timestamp, headers, rows);
    }

    // ================= SUPPLIER MATRIX =================
    async function getSupplierMatrix() {
      try {
        const id = document.getElementById("matrixIdInput").value;
        const data = await mapping1.methods.getMatrixDetails(id).call();
        const matrixInfo = await mapping1.methods.allocationMatrices(id).call();
        const timestamp = new Date(matrixInfo.timestamp * 1000).toLocaleString();

        const grouped = {};
        for (let i = 0; i < data[1].length; i++) {
          const supplier = data[3][i];
          const resource = data[4][i].toUpperCase();
          const qty = data[5][i];

          if (!grouped[supplier]) grouped[supplier] = { SUPPLIER: supplier, WATER: 0,  FOOD: 0,MEDICINE: 0, CLOTHS: 0 };
          if (grouped[supplier][resource] !== undefined) grouped[supplier][resource] += Number(qty);
        }

        lastSupplierData = { grouped, timestamp, matrixId: id };

        let html = `<h3>üè≠ Supplier Matrix | Created: ${timestamp}</h3>`;
        html += "<table><tr><th>Supplier</th><th>WATER</th><th>FOOD</th><th>MEDICINE</th><th>CLOTHS</th></tr>";
        Object.values(grouped).forEach(row => {
          html += `<tr>
            <td>${row.SUPPLIER}</td>
            <td>${row.WATER}</td>
            <td>${row.FOOD}</td>
            <td>${row.MEDICINE}</td>
            <td>${row.CLOTHS}</td>
          </tr>`;
        });
        html += "</table>";
        document.getElementById("supplierMatrix").innerHTML = html;
      } catch (err) {
        showError("Error fetching supplier matrix: " + err.message);
      }
    }

    function downloadSupplierCSV() {
      if (!lastSupplierData) return showError("Please load the Supplier Matrix first!");
      const { grouped, timestamp, matrixId } = lastSupplierData;
      const headers = ["SUPPLIER", "WATER", "FOOD", "MEDICINE",  "CLOTHS"];
      const rows = Object.values(grouped).map(r => [r.SUPPLIER, r.WATER,  r.FOOD,r.MEDICINE, r.CLOTHS]);
      downloadCSV("Supplier", matrixId, timestamp, headers, rows);
    }

    // ================= HELPER =================
    function downloadCSV(type, matrixId, timestamp, headers, rows) {
      const csvRows = [];
      csvRows.push(headers.join(","));
      rows.forEach(r => csvRows.push(r.map(c => `"${c}"`).join(",")));
      const csv = csvRows.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const timeStr = timestamp.replace(/[: ,]/g, "_");
      a.href = url;
      a.download = `${type}_Matrix_${matrixId}_${timeStr}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>


